# Core code algorithm generated by AI, post solving manually, via prompt below using CoPilot ( https://copilot.microsoft.com/ ):

"""
AI prompt:

Write a python function calculate_dial_value representing a dial of numeric values that modular arithmetic with integer values on the dial from 0 to 99. 

The parameters of foo are: 

* current - an integer value for the intial dial value e.g. 50 
* direction - either 'L' for left which decreases the current dial vallue, or 'R' for right which increases the current dial value 
* amount - an integer amount to increase (if direction is 'R') or decrease (if direction is 'L') 

Return the new dial value
"""


def calculate_dial_value(current: int, direction: str, amount: int) -> int:
    """
    Represents a dial with values from 0 to 99.
    Uses modular arithmetic to wrap around.

    Parameters:
    current (int): The initial dial value (0–99).
    direction (str): 'L' for left (decrease), 'R' for right (increase).
    amount (int): The amount to move the dial.

    Returns:
    int: The new dial value after applying the move.
    """
    if not (0 <= current <= 99):
        raise ValueError("Current must be between 0 and 99 inclusive.")
    if direction not in ('L', 'R'):
        raise ValueError("Direction must be 'L' or 'R'.")

    if direction == 'R':
        new_value = (current + amount) % 100
    else:  # direction == 'L'
        new_value = (current - amount) % 100

    return new_value


"""
AI prompt:

Write a python function to slit a provided string into the first character and the remainder as an interger value e.g. input of L68 return a tuple of 'L' and 68
"""

def split_string(s: str) -> tuple[str, int]:
    """
    Splits a string into the first character and the remainder as an integer.

    Example:
    >>> split_string("L68")
    ('L', 68)
    """
    if not s:
        raise ValueError("Input string cannot be empty")

    first_char = s[0]
    remainder = int(s[1:]) if len(s) > 1 else 0
    return first_char, remainder



def solve_part1(filename):
    ans = 0

    # Iterate over each line in the file
    dial_value = 50
    with open(filename, "r") as f:
        for line in f:
            line = line.strip()  # remove leading/trailing whitespace
            if line:             # check if not empty
                direction, amount = split_string(line)
                dial_value = calculate_dial_value(dial_value, direction, amount)
                if dial_value == 0:
                    ans += 1
    return ans    


"""
Prompt:

Write a Python function called `calculate_dial_value_with_zero_clicks(current, direction, amount)` that simulates a dial numbered 0–99 (modulo 100). The function should:

1. Accept:
   - `current`: an integer between 0 and 99 (inclusive), the starting dial position.
   - `direction`: either 'L' (left, decreasing) or 'R' (right, increasing).
   - `amount`: a non-negative integer, the number of steps to rotate.

2. Return:
   - A tuple `(new_value, zero_clicks)` where:
     - `new_value` is the final dial position after rotation.
     - `zero_clicks` is the number of times the dial passes through or lands on zero during the move.

3. Rules for counting zero clicks:
   - **Right rotation ('R'):**
     - Every full 100 steps adds one zero crossing.
     - If the final position is exactly 0, count that once (but do not double-count).
   - **Left rotation ('L'):**
     - If `amount < current`, no wrap occurs unless landing exactly on zero.
       - If final position is 0, count one click.
     - If `amount >= current`, the dial crosses zero once when going below 0, plus one for each additional full 100 steps.
     - If final position is 0, count that once (but do not double-count).
   - **Starting at zero** does not count as a click by itself; only crossings or landings during movement count.

4. Edge cases:
   - `(5, 'L', 5)` → `(0, 1)`
   - `(30, 'L', 30)` → `(0, 1)`
   - `(10, 'L', 10)` → `(0, 1)`
   - `(0, 'L', 5)` → `(95, 0)`
   - `(0, 'R', 154)` → `(54, 1)`
   - `(91, 'L', 829)` → `(62, 8)`

Ensure the function is robust for large amounts (thousands of steps) and handles multiple wraps correctly.

"""

def calculate_dial_value_with_zero_clicks(current: int, direction: str, amount: int) -> tuple[int, int]:
    """
    Dial values are 0–99 (mod 100).
    Counts zero crossings:
    - Moving right: each full +100 crosses zero once; landing on zero is not double-counted.
    - Moving left: crossing zero from a positive start counts once; then each full 100 after that adds one.
      Landing exactly on zero counts once when amount == current (from a non-zero start).
      Starting at zero does not count an initial crossing.
    """
    if not (0 <= current <= 99):
        raise ValueError("Current must be between 0 and 99 inclusive.")
    if direction not in ('L', 'R'):
        raise ValueError("Direction must be 'L' or 'R'.")

    if direction == 'R':
        total = current + amount
        new_value = total % 100
        # Each full 100 forward crosses zero once
        zero_clicks = total // 100
        # No extra increment for landing on zero; division already accounts for it
        return new_value, zero_clicks

    # direction == 'L'
    if amount <= current:
        # No wrap unless landing on zero
        new_value = (current - amount) % 100
        zero_clicks = 1 if amount == current and amount != 0 else 0
        return new_value, zero_clicks
    else:
        # We cross zero once from a positive start, then once per full 100 thereafter
        r = amount - current  # steps after first reach of zero
        new_value = (current - amount) % 100
        initial_cross = 1 if current > 0 else 0
        zero_clicks = initial_cross + (r // 100)
        # No extra increment for landing on zero here; r // 100 already captures full wraps
        return new_value, zero_clicks



import solution

def solve_part2(filename):
    ans = 0

    # Iterate over each line in the file
    dial_value = 50
    with open(filename, "r") as f:
        for line in f:
            line = line.strip()  # remove leading/trailing whitespace
            if line:             # check if not empty
                direction, amount = split_string(line)
                current_value = dial_value
                dial_value, zero_clicks = calculate_dial_value_with_zero_clicks(current_value, direction, amount)
                ans += zero_clicks

    return ans